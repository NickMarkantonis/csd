## HY342 - Παράλληλος Προγραμματισμός
### 20-02-2025 | Διάλεξη 4

#### Πρότυπα Παραλληλισμού 
##### 1. doall ή forall
###### Doall
Ο *Doall* είναι ένας τύπος παραλληλισμού που εφαρμόζεται όταν όλες οι επαναλήψεις ενός βρόχου μπορούν να εκτελεστούν ανεξάρτητα η μία απο την άλλη, χωρίς να υπάρχουν εξαρτήσεις μεταξύ τους. Αυτό σημαίνει ότι όλες οι επαναλήψεις μπορούν να εκτελεστούν ταυτόχρονα, δεδομένου ότι υπάρχουν αρκετοί επεξεργαστές.

**Χαρακτηριστικά:**
1. Δεν υπάρχουν εξαρτήσεις δεδομένων μεταξύ των επαναλήψεων
2. Όλες οι επαναλήψεις εκτελούνται ταυτόχρονα, αν υπάρχει επαρκής υπολογιστική ισχύς
3. Ιδανικό για απόλυτα ενξάρτητους υπολογισμούς.
4. Συχνά εφαρμόζεται σε [SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data) και [MIMD](https://en.wikipedia.org/wiki/Multiple_instruction,_multiple_data) αρχιτεκτονικές.

###### Forall
Ο *Forall* είναι ο πίο γενικός τρόπος παράλληλης εκτέλεσης βροχών και χρησιμοποιείται κυρίως σε γλώσσες προγραμματισμού υψηλού επιπέδου και αριθμητικούς υπολογισμούς. Σε αντίθεση με το Doall, επιτρέπει συγχρονισμό μεταξύ των επαναλήψεων, αλλα εξακολουθεί να διατηρεί μία παραλληλιστική προσέγγιση.

**Χαρακτηριστικά:**
1. Μπορεί να επιτρέπει κάποιο συγχρονισμό μεταξύ των επαναλήψεων.
2. Χρησιμοποιείται συχνά σε υπολογιστικά συστήματα με διάνυσμα και σε υψηλού επιπέδου γλώσσες προγραμματισμού
3. Εστιάζει στην περιγραφή του υπολογισμού χωρίς να καθορίζει άμεσα την ακολουθιακή ή παράλληλη εκτέλεση.

###### Πότε χρησιμοποιούμε κάθε έναν;
- **Doall**: Όταν κάθε επανάληψη μπορεί να εκτελεστεί χωρίς καμία εξάρτηση από άλλες.
- **Forall**: Όταν υπάρχει κάποια εξάρτηση, άλλα μπορούμε να επιτρέψουμε έναν ελεγχόμενο συγχρονισμό.

###### Μετατροπή κώδικα:
- Αρχικός Κώδικας:
```c
for(i = 0; i < 1000000; i++) {
    C[i] = A[i] + B[i];
}
```
- Μετά την μετατροπή:
```c
struct thread_arg {
    int from;
    int to;
    pthread_t thread;
};

void ∗do_work(void ∗voidarg) {
    struct thread_arg ∗arg = (struct thread_arg ∗)voidarg;
    for(i = arg->from; i < arg->to; i++) {
        C[i] = A[i] + B[i];
    }
}

void parallelfor() {
    struct thread_arg[NUM_THREADS];
    int from = 0, to = 1000000;
    int step = to / NUM_THREADS;
    int i ;
    for(i = 0; i < NUM_THREADS; i++) {
        thread_arg[i].from = from;
        thread_arg[i].to = (i < NUM_THREADS-1) ? (from + step) : to;
        from = to;
        pthread_create(&thread_arg[i].thread, NULL, &do_work, &thread_arg[i]);
    }
    for(i = 0; i < NUM_THREADS; i++) {
        pthread_join(thread_arg[i].thread, NULL);
    }
}
```

##### 2. Pipeline
##### 3. Task (recursive)
##### 4. MapReduce
